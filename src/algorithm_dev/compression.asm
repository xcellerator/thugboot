; This is just a regular NASM source to be compiled into an ELF.
; The purpose was to get the logic right in assembly before rewriting in 16-bit real mode.
; Compile with: nasm -f elf compression.asm
; Link with: ld -m elf_i386 compression.o -o compression
; Run with: ./compression
; You should see the ThugCrowd logo

SECTION .data

logo	db	0x11 , 0x20 , 0x0e , 0x5f , 0x05 , 0x20 , 0x06 , 0x5f , 0x06 , 0x20 , 0x03 , 0x5f , 0x01 , 0x0a , 0x01 , 0x0d , 0x11 , 0x20 , 0x01 , 0x5c , 0x03 , 0x20 , 0x01 , 0x5f , 0x04 , 0x20 , 0x01 , 0x5f , 0x03 , 0x20 , 0x01 , 0x2f , 0x04 , 0x2d , 0x01 , 0x2f , 0x05 , 0x20 , 0x01 , 0x2f , 0x05 , 0x5f , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x5c , 0x08 , 0x5f , 0x01 , 0x0a , 0x01 , 0x0d , 0x11 , 0x20 , 0x01 , 0x2f , 0x03 , 0x5f , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x03 , 0x5f , 0x01 , 0x5c , 0x02 , 0x20 , 0x01 , 0x5f , 0x01 , 0x2f , 0x05 , 0x20 , 0x02 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x5f , 0x04 , 0x20 , 0x01 , 0x5c , 0x01 , 0x0a , 0x01 , 0x0d , 0x14 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x02 , 0x2f , 0x06 , 0x20 , 0x01 , 0x5c , 0x05 , 0x20 , 0x02 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x01 , 0x0a , 0x01 , 0x0d , 0x13 , 0x20 , 0x01 , 0x2f , 0x05 , 0x5f , 0x01 , 0x5c , 0x07 , 0x20 , 0x01 , 0x2f , 0x05 , 0x5f , 0x01 , 0x5c , 0x01 , 0x20 , 0x09 , 0x5f , 0x01 , 0x5c , 0x05 , 0x5f , 0x03 , 0x20 , 0x01 , 0x2f , 0x01 , 0x0a , 0x01 , 0x0d , 0x1a , 0x20 , 0x01 , 0x5c , 0x05 , 0x5f , 0x01 , 0x2f , 0x07 , 0x20 , 0x01 , 0x5c , 0x01 , 0x2f , 0x05 , 0x20 , 0x01 , 0x5c , 0x0b , 0x5f , 0x01 , 0x5c , 0x01 , 0x0a , 0x01 , 0x0d , 0x01 , 0x0a , 0x01 , 0x0d , 0x0e , 0x20 , 0x09 , 0x5f , 0x02 , 0x20 , 0x0b , 0x5f , 0x01 , 0x20 , 0x08 , 0x5f , 0x01 , 0x20 , 0x07 , 0x5f , 0x03 , 0x20 , 0x09 , 0x5f , 0x01 , 0x0a , 0x01 , 0x0d , 0x0c , 0x20 , 0x01 , 0x5f , 0x01 , 0x2f , 0x08 , 0x20 , 0x01 , 0x2f , 0x01 , 0x5f , 0x01 , 0x20 , 0x01 , 0x29 , 0x03 , 0x20 , 0x01 , 0x2e , 0x01 , 0x5f , 0x04 , 0x20 , 0x02 , 0x2f , 0x02 , 0x20 , 0x02 , 0x5f , 0x04 , 0x20 , 0x01 , 0x58 , 0x06 , 0x20 , 0x01 , 0x2f , 0x03 , 0x5f , 0x01 , 0x5c , 0x06 , 0x5f , 0x02 , 0x20 , 0x01 , 0x5c , 0x01 , 0x0a , 0x01 , 0x0d , 0x0c , 0x20 , 0x01 , 0x5c , 0x05 , 0x20 , 0x01 , 0x7c , 0x02 , 0x5f , 0x01 , 0x2f , 0x02 , 0x20 , 0x01 , 0x5c , 0x01 , 0x5f , 0x03 , 0x20 , 0x01 , 0x7c , 0x01 , 0x2f , 0x02 , 0x20 , 0x01 , 0x5f , 0x01 , 0x2f , 0x05 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x02 , 0x2f , 0x05 , 0x20 , 0x01 , 0x2f , 0x06 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x3e , 0x01 , 0x0a , 0x01 , 0x0d , 0x0d , 0x20 , 0x01 , 0x5c , 0x04 , 0x20 , 0x01 , 0x7c , 0x07 , 0x20 , 0x01 , 0x2f , 0x02 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x5c , 0x01 , 0x5f , 0x03 , 0x20 , 0x01 , 0x2f , 0x04 , 0x20 , 0x01 , 0x2f , 0x01 , 0x5f , 0x04 , 0x20 , 0x01 , 0x2f , 0x01 , 0x5c , 0x05 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x2f , 0x01 , 0x0a , 0x01 , 0x0d , 0x0e , 0x20 , 0x01 , 0x5c , 0x0a , 0x5f , 0x01 , 0x2f , 0x03 , 0x20 , 0x01 , 0x5c , 0x06 , 0x20 , 0x01 , 0x2f , 0x06 , 0x5f , 0x01 , 0x2f , 0x01 , 0x20 , 0x01 , 0x2f , 0x04 , 0x5f , 0x01 , 0x2f , 0x01 , 0x5c , 0x03 , 0x5f , 0x02 , 0x20 , 0x01 , 0x58 , 0x06 , 0x20 , 0x01 , 0x2f , 0x01 , 0x0a , 0x01 , 0x0d , 0x18 , 0x20 , 0x01 , 0x5c , 0x03 , 0x5f , 0x01 , 0x2f , 0x01 , 0x20 , 0x01 , 0x5c , 0x04 , 0x5f , 0x01 , 0x2f , 0x13 , 0x20 , 0x01 , 0x5c , 0x01 , 0x2f , 0x01 , 0x20 , 0x01 , 0x5c , 0x04 , 0x5f , 0x01 , 0x2f , 0x01 , 0x0a , 0x01 , 0x0d , 0x01 , 0x0a , 0x01 , 0x0d , 0x1e , 0x20 , 0x03 , 0x77 , 0x01 , 0x2e , 0x01 , 0x74 , 0x01 , 0x68 , 0x01 , 0x75 , 0x01 , 0x67 , 0x01 , 0x63 , 0x01 , 0x72 , 0x01 , 0x6f , 0x01 , 0x77 , 0x01 , 0x64 , 0x01 , 0x2e , 0x01 , 0x63 , 0x01 , 0x6f , 0x01 , 0x6d , 0x01 , 0x00

SECTION .text
global _start

_start:
	mov esi, logo
	jmp .process
	.process:
		mov eax, [esi]		; Store logo pointer in EAX, so we can address AH
		cmp eax, 0h		; Check if we've reach the end of the compressed string
		jz .finished		; If yes, jump to .finished and quit
		mov cl, [esi]		; ECX = count
		inc esi			; ESI = char
	.printLoop:
		push ecx	; Preserve ECX (count)
		mov eax, 4h	; SYS_WRITE
		mov ebx, 1h	; STDOUT
		mov ecx, esi	; ECX = char
		mov edx, 1h	; EDX = string length = 1
		int 80h		; Kernel Interrupt
		pop ecx		; Restore ECX (count)
		dec ecx		; Decrement Counter
		cmp ecx, 0h	; Check if we've printed everything
		jz .nextChar	; If so, jump to .nextChar
		jmp .printLoop	; Otherwise, jump to .printLoop
	.nextChar:
		inc esi		; ESI = count
		jmp .process

	.finished:
		mov ebx, 0h	; Return 0
		mov eax, 1h	; SYS_EXIT
		int 80h		; Kernel Interrupt
		ret
